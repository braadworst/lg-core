(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';function _asyncToGenerator(a){return function(){var b=a.apply(this,arguments);return new Promise(function(c,d){function e(f,g){try{var h=b[f](g),j=h.value}catch(k){return void d(k)}return h.done?void c(j):Promise.resolve(j).then(function(k){e('next',k)},function(k){e('throw',k)})}return e('next')})}}function _toConsumableArray(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}return Array.from(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var check=require('check-types');module.exports=function(a){var o=function(){var E=_asyncToGenerator(regeneratorRuntime.mark(function F(){var G,H,I,J,K,L,M,N,O;return regeneratorRuntime.wrap(function(Q){for(;;)switch(Q.prev=Q.next){case 0:if(G=t.shift(),!G){Q.next=26;break}if(H=function mergeRelay(){var R=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};check.assert.object(R,'Relay additions need to be an object'),check.assert.not.assigned(R.extensions,'Cannot assign extensions as a relay property, this is a reserved property'),check.assert.not.assigned(R.exit,'Cannot assign exit as a relay property, this is a reserved property'),check.assert.not.assigned(R.update,'Cannot assign update as a relay property, this is a reserved property'),check.assert.not.assigned(R.parameters,'Cannot assign parameters as a relay property, this is a reserved property'),u=Object.assign({},u,R)},I=function _thunkifyMiddleware(R){var S=1<arguments.length&&void 0!==arguments[1]&&arguments[1],T=z[R];return check.assert.assigned(T,'Middleware '+R+' not found'),check.assert.function(T,'Middleware needs to be a function'),function(){var U=_asyncToGenerator(regeneratorRuntime.mark(function V(W){var X,Y;return regeneratorRuntime.wrap(function($){for(;;)switch($.prev=$.next){case 0:return $.prev=0,H(W),X=0===s.length?function(_){H(_),o()}:I(s.shift(),S),Y=[X,u].concat(_toConsumableArray(G.parameters)),-1<x.indexOf(R)&&u.error?Y=[].concat(_toConsumableArray(G.parameters),[X,u.error]):-1<x.indexOf(R)&&(Y=[].concat(_toConsumableArray(G.parameters),[X])),$.next=7,T.apply(void 0,_toConsumableArray(Y));case 7:$.next=22;break;case 9:if($.prev=9,$.t0=$['catch'](0),!S){$.next=15;break}console.error($.t0),$.next=22;break;case 15:if(u={error:$.t0,extensions:y,update:m,exit:n},s=O,0===s.length&&(console.warn('No "error" middleware found'),console.error($.t0)),s=[].concat(_toConsumableArray(s),_toConsumableArray(M)),!(0<s.length)){$.next=22;break}return $.next=22,I(s.shift(),!0)();case 22:case'end':return $.stop();}},V,this,[[0,9]])}));return function(){return U.apply(this,arguments)}}()},(w||!u)&&(u={extensions:y,update:m,exit:n}),r=!0,check.assert.assigned(G.options.matchValue,'Update function cannot find a matchValue'),J=v.parse(G.options.matchValue),u=Object.assign({},u,{parameters:J.parameters}),J=J.path,K=G.options.updateType?G.options.updateType:q,L=C[a],M=L.done[K]?L.done[K]:[],N=L.noMatch[K]?L.noMatch[K]:[],O=L.error[K]?L.error[K]:[],s=L.run[K]?L.run[K].filter(function(R){return R.matchValue===J||'*'===R.matchValue}).map(function(R){return R.middlewareId}):[],0===s.length&&(s=N),s=[].concat(_toConsumableArray(s),_toConsumableArray(M)),!(0<s.length)){Q.next=23;break}return Q.next=21,I(s.shift())();case 21:Q.next=24;break;case 23:o();case 24:Q.next=27;break;case 26:r=!1;case 27:case'end':return Q.stop();}},F,this)}));return function(){return E.apply(this,arguments)}}(),p=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},q='GET',r=!1,s=[],t=[],u=void 0,v={add:function add(){},parse:function parse(E){return{path:E,parameters:{}}}},w=!0,x=[],y={},z={},B=[a],C=_defineProperty({},a,b(a)),D={extension:function(E,F){var G=2<arguments.length&&void 0!==arguments[2]&&arguments[2];return check.assert.not.undefined(E,'Extension id cannot be empty'),check.assert.not.undefined(F,'Extension cannot be empty'),check.assert.match(E,/^[a-z0-9]+$/i,'Extension id needs to be a string containing only letters and or numbers'),check.assert.not.assigned(y[E],'"'+E+'" has already been defined as an extension'),y[E]=G?F(l):F,D},middleware:function(E){for(var F=arguments.length,G=Array(1<F?F-1:0),H=1;H<F;H++)G[H-1]=arguments[H];return check.assert.nonEmptyObject(E,'Provided middleware needs to be a non empty object'),Object.keys(E).forEach(function(I){check.assert.not.assigned(z[I],'"'+I+'" has already been defined as middleware'),check.assert.function(E[I],'"'+I+'" middleware is not a function')}),G.length&&(check.assert.array.of.string(G,'All traditional middleware names need to be strings'),G.forEach(function(I,J){check.assert.equal(G.indexOf(I),J,'Duplicate values found for traditional middleware "'+I+'"'),check.assert.equal(x.indexOf(I),-1,'"'+I+'" has already been defined as a traditional middleware function')}),x=[].concat(_toConsumableArray(x),G)),z=Object.assign({},z,E),D},where:function(){for(var E=arguments.length,F=Array(E),G=0;G<E;G++)F[G]=arguments[G];return check.assert.greater(F.length,0,'Where method missing parameters'),F.forEach(function(H){check.assert.not.undefined(H,'Environment id cannot be empty'),check.assert.match(H,/^[a-z0-9]+$/i,'Environment id needs to be a string containing only letters and or numbers'),C[H]||(C[H]=b(H))}),B=F,D},run:function(E,F){var G=2<arguments.length&&void 0!==arguments[2]?arguments[2]:q;return check.assert.not.undefined(E,'Match value cannot be empty'),check.assert.string(E,'Match value needs to be a string'),check.assert.not.undefined(F,'Middleware id cannot be empty'),check.assert.match(F,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."'),check.assert.match(G,/^[a-z0-9]+$/i,'Update type needs to be a string containing only letters and or numbers'),v.add(E),B.forEach(function(H){Array.isArray(C[H].run[G])?C[H].run[G].push({middlewareId:F,matchValue:E}):C[H].run[G]=[{middlewareId:F,matchValue:E}]}),D},error:function(E){var F=1<arguments.length&&void 0!==arguments[1]?arguments[1]:q;return check.assert.not.undefined(E,'Middleware id cannot be empty'),check.assert.match(F,/^[a-z0-9]+$/i,'Update type needs to be a string containing only letters and or numbers'),check.assert.match(E,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."'),B.forEach(function(G){Array.isArray(C[G].error[F])?C[G].error[F].push(E):C[G].error[F]=[E]}),D},noMatch:function(E){var F=1<arguments.length&&void 0!==arguments[1]?arguments[1]:q;return check.assert.not.undefined(E,'Middleware id cannot be empty'),check.assert.match(F,/^[a-z0-9]+$/i,'Update type needs to be a string containing only letters and or numbers'),check.assert.match(E,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."'),B.forEach(function(G){Array.isArray(C[G].noMatch[F])?C[G].noMatch[F].push(E):C[G].noMatch[F]=[E]}),D},done:function(E){var F=1<arguments.length&&void 0!==arguments[1]?arguments[1]:q;return check.assert.not.undefined(E,'Middleware id cannot be empty'),check.assert.match(F,/^[a-z0-9]+$/i,'Update type needs to be a string containing only letters and or numbers'),check.assert.match(E,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."'),B.forEach(function(G){Array.isArray(C[G].done[F])?C[G].done[F].push(E):C[G].done[F]=[E]}),D},update:l,parser:function(E){return check.assert.function(E.add,'Parser needs to have a method called "add"'),check.assert.function(E.parse,'Parser needs to have a method called "parse"'),v=E,D}};function b(E){return check.assert.not.undefined(E,'Environment id cannot be empty'),check.assert.match(E,/^[a-z0-9]+$/i,'Environment id needs to be a string containing only letters and or numbers'),{id:E,run:{},noMatch:{},error:{},done:{}}}function l(E){for(var F=arguments.length,G=Array(1<F?F-1:0),H=1;H<F;H++)G[H-1]=arguments[H];return t.push({options:E,parameters:G}),!1==r&&o(),D}function m(E){t.push({options:E,parameters:[]}),!1==r&&o()}function n(){s=[],o()}return void 0!==p.resetAfterCycle&&(check.assert.boolean(p.resetAfterCycle,'resetAfterCycle needs to be a boolean'),w=p.resetAfterCycle),D};

},{"check-types":2}],2:[function(require,module,exports){
/*globals define, module, Symbol */
/*jshint -W056 */

(function (globals) {
  'use strict';

  var strings, messages, predicates, functions,
      assert, not, maybe, collections, slice;

  strings = {
    v: 'value',
    n: 'number',
    s: 'string',
    b: 'boolean',
    o: 'object',
    t: 'type',
    a: 'array',
    al: 'array-like',
    i: 'iterable',
    d: 'date',
    f: 'function',
    l: 'length'
  };

  messages = {};
  predicates = {};

  [
    { n: 'equal', f: equal, s: 'v' },
    { n: 'undefined', f: isUndefined, s: 'v' },
    { n: 'null', f: isNull, s: 'v' },
    { n: 'assigned', f: assigned, s: 'v' },
    { n: 'includes', f: includes, s: 'v' },
    { n: 'zero', f: zero },
    { n: 'infinity', f: infinity },
    { n: 'number', f: number },
    { n: 'integer', f: integer },
    { n: 'even', f: even },
    { n: 'odd', f: odd },
    { n: 'greater', f: greater },
    { n: 'less', f: less },
    { n: 'between', f: between },
    { n: 'greaterOrEqual', f: greaterOrEqual },
    { n: 'lessOrEqual', f: lessOrEqual },
    { n: 'inRange', f: inRange },
    { n: 'positive', f: positive },
    { n: 'negative', f: negative },
    { n: 'string', f: string, s: 's' },
    { n: 'emptyString', f: emptyString, s: 's' },
    { n: 'nonEmptyString', f: nonEmptyString, s: 's' },
    { n: 'contains', f: contains, s: 's' },
    { n: 'match', f: match, s: 's' },
    { n: 'boolean', f: boolean, s: 'b' },
    { n: 'object', f: object, s: 'o' },
    { n: 'emptyObject', f: emptyObject, s: 'o' },
    { n: 'nonEmptyObject', f: nonEmptyObject, s: 'o' },
    { n: 'instanceStrict', f: instanceStrict, s: 't' },
    { n: 'instance', f: instance, s: 't' },
    { n: 'like', f: like, s: 't' },
    { n: 'array', f: array, s: 'a' },
    { n: 'emptyArray', f: emptyArray, s: 'a' },
    { n: 'nonEmptyArray', f: nonEmptyArray, s: 'a' },
    { n: 'arrayLike', f: arrayLike, s: 'al' },
    { n: 'iterable', f: iterable, s: 'i' },
    { n: 'date', f: date, s: 'd' },
    { n: 'function', f: isFunction, s: 'f' },
    { n: 'hasLength', f: hasLength, s: 'l' },
  ].map(function (data) {
    var n = data.n;
    messages[n] = 'Invalid ' + strings[data.s || 'n'];
    predicates[n] = data.f;
  });

  functions = {
    apply: apply,
    map: map,
    all: all,
    any: any
  };

  collections = [ 'array', 'arrayLike', 'iterable', 'object' ];
  slice = Array.prototype.slice;

  functions = mixin(functions, predicates);
  assert = createModifiedPredicates(assertModifier, assertImpl);
  not = createModifiedPredicates(notModifier, notImpl);
  maybe = createModifiedPredicates(maybeModifier, maybeImpl);
  assert.not = createModifiedModifier(assertModifier, not);
  assert.maybe = createModifiedModifier(assertModifier, maybe);

  collections.forEach(createOfPredicates);
  createOfModifiers(assert, assertModifier);
  createOfModifiers(not, notModifier);
  collections.forEach(createMaybeOfModifiers);

  exportFunctions(mixin(functions, {
    assert: assert,
    not: not,
    maybe: maybe
  }));

  /**
   * Public function `equal`.
   *
   * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
   * Returns false otherwise.
   */
  function equal (lhs, rhs) {
    return lhs === rhs;
  }

  /**
   * Public function `undefined`.
   *
   * Returns true if `data` is undefined, false otherwise.
   */
  function isUndefined (data) {
    return data === undefined;
  }

  /**
   * Public function `null`.
   *
   * Returns true if `data` is null, false otherwise.
   */
  function isNull (data) {
    return data === null;
  }

  /**
   * Public function `assigned`.
   *
   * Returns true if `data` is not null or undefined, false otherwise.
   */
  function assigned (data) {
    return ! isUndefined(data) && ! isNull(data);
  }

  /**
   * Public function `zero`.
   *
   * Returns true if `data` is zero, false otherwise.
   */
  function zero (data) {
    return data === 0;
  }

  /**
   * Public function `infinity`.
   *
   * Returns true if `data` is positive or negative infinity, false otherwise.
   */
  function infinity (data) {
    return data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `number`.
   *
   * Returns true if `data` is a number, false otherwise.
   */
  function number (data) {
    return typeof data === 'number' &&
      isNaN(data) === false &&
      data !== Number.POSITIVE_INFINITY &&
      data !== Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `integer`.
   *
   * Returns true if `data` is an integer, false otherwise.
   */
  function integer (data) {
    return number(data) && data % 1 === 0;
  }

  /**
   * Public function `even`.
   *
   * Returns true if `data` is an even number, false otherwise.
   */
  function even (data) {
    return number(data) && data % 2 === 0;
  }

  /**
   * Public function `odd`.
   *
   * Returns true if `data` is an odd number, false otherwise.
   */
  function odd (data) {
    return integer(data) && !even(data);
  }

  /**
   * Public function `greater`.
   *
   * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
   */
  function greater (lhs, rhs) {
    return number(lhs) && lhs > rhs;
  }

  /**
   * Public function `less`.
   *
   * Returns true if `lhs` is a number less than `rhs`, false otherwise.
   */
  function less (lhs, rhs) {
    return number(lhs) && lhs < rhs;
  }

  /**
   * Public function `between`.
   *
   * Returns true if `data` is a number between `x` and `y`, false otherwise.
   */
  function between (data, x, y) {
    if (x < y) {
      return greater(data, x) && less(data, y);
    }

    return less(data, x) && greater(data, y);
  }

  /**
   * Public function `greaterOrEqual`.
   *
   * Returns true if `lhs` is a number greater than or equal to `rhs`, false
   * otherwise.
   */
  function greaterOrEqual (lhs, rhs) {
    return number(lhs) && lhs >= rhs;
  }

  /**
   * Public function `lessOrEqual`.
   *
   * Returns true if `lhs` is a number less than or equal to `rhs`, false
   * otherwise.
   */
  function lessOrEqual (lhs, rhs) {
    return number(lhs) && lhs <= rhs;
  }

  /**
   * Public function `inRange`.
   *
   * Returns true if `data` is a number in the range `x..y`, false otherwise.
   */
  function inRange (data, x, y) {
    if (x < y) {
      return greaterOrEqual(data, x) && lessOrEqual(data, y);
    }

    return lessOrEqual(data, x) && greaterOrEqual(data, y);
  }

  /**
   * Public function `positive`.
   *
   * Returns true if `data` is a positive number, false otherwise.
   */
  function positive (data) {
    return greater(data, 0);
  }

  /**
   * Public function `negative`.
   *
   * Returns true if `data` is a negative number, false otherwise.
   */
  function negative (data) {
    return less(data, 0);
  }

  /**
   * Public function `string`.
   *
   * Returns true if `data` is a string, false otherwise.
   */
  function string (data) {
    return typeof data === 'string';
  }

  /**
   * Public function `emptyString`.
   *
   * Returns true if `data` is the empty string, false otherwise.
   */
  function emptyString (data) {
    return data === '';
  }

  /**
   * Public function `nonEmptyString`.
   *
   * Returns true if `data` is a non-empty string, false otherwise.
   */
  function nonEmptyString (data) {
    return string(data) && data !== '';
  }

  /**
   * Public function `contains`.
   *
   * Returns true if `data` is a string that contains `substring`, false
   * otherwise.
   */
  function contains (data, substring) {
    return string(data) && data.indexOf(substring) !== -1;
  }

  /**
   * Public function `match`.
   *
   * Returns true if `data` is a string that matches `regex`, false otherwise.
   */
  function match (data, regex) {
    return string(data) && !! data.match(regex);
  }

  /**
   * Public function `boolean`.
   *
   * Returns true if `data` is a boolean value, false otherwise.
   */
  function boolean (data) {
    return data === false || data === true;
  }

  /**
   * Public function `object`.
   *
   * Returns true if `data` is a plain-old JS object, false otherwise.
   */
  function object (data) {
    return Object.prototype.toString.call(data) === '[object Object]';
  }

  /**
   * Public function `emptyObject`.
   *
   * Returns true if `data` is an empty object, false otherwise.
   */
  function emptyObject (data) {
    return object(data) && Object.keys(data).length === 0;
  }

  /**
   * Public function `nonEmptyObject`.
   *
   * Returns true if `data` is a non-empty object, false otherwise.
   */
  function nonEmptyObject (data) {
    return object(data) && Object.keys(data).length > 0;
  }

  /**
   * Public function `instanceStrict`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   */
  function instanceStrict (data, prototype) {
    try {
      return data instanceof prototype;
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `instance`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   * Falls back to testing constructor.name and Object.prototype.toString
   * if the initial instanceof test fails.
   */
  function instance (data, prototype) {
    try {
      return instanceStrict(data, prototype) ||
        data.constructor.name === prototype.name ||
        Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `like`.
   *
   * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
   * of the properties of `archetype` (the 'duck'), false otherwise.
   */
  function like (data, archetype) {
    var name;

    for (name in archetype) {
      if (archetype.hasOwnProperty(name)) {
        if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
          return false;
        }

        if (object(data[name]) && like(data[name], archetype[name]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Public function `array`.
   *
   * Returns true if `data` is an array, false otherwise.
   */
  function array (data) {
    return Array.isArray(data);
  }

  /**
   * Public function `emptyArray`.
   *
   * Returns true if `data` is an empty array, false otherwise.
   */
  function emptyArray (data) {
    return array(data) && data.length === 0;
  }

  /**
   * Public function `nonEmptyArray`.
   *
   * Returns true if `data` is a non-empty array, false otherwise.
   */
  function nonEmptyArray (data) {
    return array(data) && data.length > 0;
  }

  /**
   * Public function `arrayLike`.
   *
   * Returns true if `data` is an array-like object, false otherwise.
   */
  function arrayLike (data) {
    return assigned(data) && number(data.length);
  }

  /**
   * Public function `iterable`.
   *
   * Returns true if `data` is an iterable, false otherwise.
   */
  function iterable (data) {
    if (typeof Symbol === 'undefined') {
      // Fall back to `arrayLike` predicate in pre-ES6 environments.
      return arrayLike(data);
    }

    return assigned(data) && isFunction(data[Symbol.iterator]);
  }

  /**
   * Public function `includes`.
   *
   * Returns true if `data` contains `value`, false otherwise.
   */
  function includes (data, value) {
    var iterator, iteration;

    if (not.assigned(data)) {
      return false;
    }

    try {
      if (typeof Symbol !== 'undefined' && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (! iteration.done);

        return false;
      }

      Object.keys(data).forEach(function (key) {
        if (data[key] === value) {
          throw 0;
        }
      });
    } catch (ignore) {
      return true;
    }

    return false;
  }

  /**
   * Public function `hasLength`.
   *
   * Returns true if `data` has a length property that equals `length`, false
   * otherwise.
   */
  function hasLength (data, length) {
    return assigned(data) && data.length === length;
  }

  /**
   * Public function `date`.
   *
   * Returns true if `data` is a valid date, false otherwise.
   */
  function date (data) {
    try {
      return instance(data, Date) && integer(data.getTime());
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `function`.
   *
   * Returns true if `data` is a function, false otherwise.
   */
  function isFunction (data) {
    return typeof data === 'function';
  }

  /**
   * Public function `apply`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result array. If the same function is to be applied across all of the
   * data, a single predicate function may be passed in.
   *
   */
  function apply (data, predicates) {
    assert.array(data);

    if (isFunction(predicates)) {
      return data.map(function (value) {
        return predicates(value);
      });
    }

    assert.array(predicates);
    assert.hasLength(data, predicates.length);

    return data.map(function (value, index) {
      return predicates[index](value);
    });
  }

  /**
   * Public function `map`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result object. Supports nested objects. If the `data` is not nested and
   * the same function is to be applied across all of it, a single predicate
   * function may be passed in.
   *
   */
  function map (data, predicates) {
    assert.object(data);

    if (isFunction(predicates)) {
      return mapSimple(data, predicates);
    }

    assert.object(predicates);

    return mapComplex(data, predicates);
  }

  function mapSimple (data, predicate) {
    var result = {};

    Object.keys(data).forEach(function (key) {
      result[key] = predicate(data[key]);
    });

    return result;
  }

  function mapComplex (data, predicates) {
    var result = {};

    Object.keys(predicates).forEach(function (key) {
      var predicate = predicates[key];

      if (isFunction(predicate)) {
        if (not.assigned(data)) {
          result[key] = !!predicate.m;
        } else {
          result[key] = predicate(data[key]);
        }
      } else if (object(predicate)) {
        result[key] = mapComplex(data[key], predicate);
      }
    });

    return result;
  }

  /**
   * Public function `all`
   *
   * Check that all boolean values are true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function all (data) {
    if (array(data)) {
      return testArray(data, false);
    }

    assert.object(data);

    return testObject(data, false);
  }

  function testArray (data, result) {
    var i;

    for (i = 0; i < data.length; i += 1) {
      if (data[i] === result) {
        return result;
      }
    }

    return !result;
  }

  function testObject (data, result) {
    var key, value;

    for (key in data) {
      if (data.hasOwnProperty(key)) {
        value = data[key];

        if (object(value) && testObject(value, result) === result) {
          return result;
        }

        if (value === result) {
          return result;
        }
      }
    }

    return !result;
  }

  /**
   * Public function `any`
   *
   * Check that at least one boolean value is true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function any (data) {
    if (array(data)) {
      return testArray(data, true);
    }

    assert.object(data);

    return testObject(data, true);
  }

  function mixin (target, source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });

    return target;
  }

  /**
   * Public modifier `assert`.
   *
   * Throws if `predicate` returns false.
   */
  function assertModifier (predicate, defaultMessage) {
    return function () {
      assertPredicate(predicate, arguments, defaultMessage);
    };
  }

  function assertPredicate (predicate, args, defaultMessage) {
    var argCount = predicate.l || predicate.length;
    var message = args[argCount];
    var ErrorType = args[argCount + 1];
    assertImpl(
      predicate.apply(null, args),
      nonEmptyString(message) ? message : defaultMessage,
      isFunction(ErrorType) ? ErrorType : TypeError
    );
  }

  function assertImpl (value, message, ErrorType) {
    if (value === false) {
      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
  }

  /**
   * Public modifier `not`.
   *
   * Negates `predicate`.
   */
  function notModifier (predicate) {
    var modifiedPredicate = function () {
      return notImpl(predicate.apply(null, arguments));
    };
    modifiedPredicate.l = predicate.length;
    return modifiedPredicate;
  }

  function notImpl (value) {
    return !value;
  }

  /**
   * Public modifier `maybe`.
   *
   * Returns true if predicate argument is  null or undefined,
   * otherwise propagates the return value from `predicate`.
   */
  function maybeModifier (predicate) {
    var modifiedPredicate = function () {
      if (not.assigned(arguments[0])) {
        return true;
      }

      return predicate.apply(null, arguments);
    };
    modifiedPredicate.l = predicate.length;

    // Hackishly indicate that this is a maybe.xxx predicate.
    // Without this flag, the alternative would be to iterate
    // through the maybe predicates or use indexOf to check,
    // which would be time-consuming.
    modifiedPredicate.m = true;

    return modifiedPredicate;
  }

  function maybeImpl (value) {
    if (assigned(value) === false) {
      return true;
    }

    return value;
  }

  /**
   * Public modifier `of`.
   *
   * Applies the chained predicate to members of the collection.
   */
  function ofModifier (target, type, predicate) {
    var modifiedPredicate = function () {
      var collection, args;

      collection = arguments[0];

      if (target === 'maybe' && not.assigned(collection)) {
        return true;
      }

      if (!type(collection)) {
        return false;
      }

      collection = coerceCollection(type, collection);
      args = slice.call(arguments, 1);

      try {
        collection.forEach(function (item) {
          if (
            (target !== 'maybe' || assigned(item)) &&
            !predicate.apply(null, [ item ].concat(args))
          ) {
            // TODO: Replace with for...of when ES6 is required.
            throw 0;
          }
        });
      } catch (ignore) {
        return false;
      }

      return true;
    };
    modifiedPredicate.l = predicate.length;
    return modifiedPredicate;
  }

  function coerceCollection (type, collection) {
    switch (type) {
      case arrayLike:
        return slice.call(collection);
      case object:
        return Object.keys(collection).map(function (key) {
          return collection[key];
        });
      default:
        return collection;
    }
  }

  function createModifiedPredicates (modifier, object) {
    return createModifiedFunctions([ modifier, predicates, object ]);
  }

  function createModifiedFunctions (args) {
    var modifier, object, functions, result;

    modifier = args.shift();
    object = args.pop();
    functions = args.pop();

    result = object || {};

    Object.keys(functions).forEach(function (key) {
      Object.defineProperty(result, key, {
        configurable: false,
        enumerable: true,
        writable: false,
        value: modifier.apply(null, args.concat(functions[key], messages[key]))
      });
    });

    return result;
  }

  function createModifiedModifier (modifier, modified) {
    return createModifiedFunctions([ modifier, modified, null ]);
  }

  function createOfPredicates (key) {
    predicates[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, null), predicates[key], predicates, null ]
    );
  }

  function createOfModifiers (base, modifier) {
    collections.forEach(function (key) {
      base[key].of = createModifiedModifier(modifier, predicates[key].of);
    });
  }

  function createMaybeOfModifiers (key) {
    maybe[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, 'maybe'), predicates[key], predicates, null ]
    );
    assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
    assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
  }

  function exportFunctions (functions) {
    if (typeof define === 'function' && define.amd) {
      define(function () {
        return functions;
      });
    } else if (typeof module !== 'undefined' && module !== null && module.exports) {
      module.exports = functions;
    } else {
      globals.check = functions;
    }
  }
}(this));

},{}]},{},[1]);
